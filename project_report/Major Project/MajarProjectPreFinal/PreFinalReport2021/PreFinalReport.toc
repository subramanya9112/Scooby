\babel@toc {english}{}\relax 
\contentsline {chapter}{Acknowledgements}{iv}{Item.4}%
\contentsline {chapter}{Abstract}{viii}{chapter*.1}%
\contentsline {paragraph}{\normalfont {An online multiplayer game allows users from across the world to connect and play together. Most modern multiplayer games use the client-server architecture. However, in these types of online games, there are issues of latency and performance. To solve these issues, we are building an online scalable low latency multiplayer game using Docker containers. Docker containers can be deployed on a cloud nearest to the client reducing latency and they also enable easy management of game servers. }}{viii}{section*.3}%
\contentsline {paragraph}{\normalfont {The game would be implemented in the form of a web application. The basic architecture consists of the game as a client-server model. Any number of clients can join the server and each client has their own game instance in the server, grouped under rooms. A cluster of docker containers are used to run the server. We make use of the Phaser game framework to render the game, maintain the game state and we use MongoDB for the database. The Docker containers will be hosted on a cloud. }}{viii}{section*.4}%
\contentsline {paragraph}{\normalfont {The game will be able to provide cross-platform support. The game would be a fast-paced combat game and will be able to establish real time communication between the user game-play session and the server. The game will also be able to allow users to create private and public rooms for game sessions and the game server will run on docker containers. }}{viii}{section*.5}%
\contentsline {chapter}{List of Figures}{ix}{chapter*.6}%
\contentsline {chapter}{\numberline {1}Introduction}{1}{chapter.1}%
\contentsline {section}{\numberline {1.1}Background Study}{1}{section.1.1}%
\contentsline {paragraph}{\normalfont {A multiplayer game is one in which more than one person can play in the same game environment at the same time, either locally and on the same computing system, locally and on different computing systems via a local area network, or locally and on different computing systems via a wide area network, most commonly the Internet.}}{1}{section*.7}%
\contentsline {paragraph}{\normalfont {The game will be having the following features:}}{1}{section*.8}%
\contentsline {paragraph}{\normalfont {The types of multiplayer games are: }}{1}{section*.9}%
\contentsline {paragraph}{\normalfont {The game would be an online multiplayer game where players are not restricted to the same network. This can be implemented in two ways as follows:}}{2}{section*.10}%
\contentsline {paragraph}{\normalfont {Most modern multiplayer games use the client-server architecture. However, in these types of online games, there are issues of latency and performance. The primary causes of latency are and other performance issues are:}}{2}{section*.11}%
\contentsline {paragraph}{\normalfont {The solution to the above problems is to use docker containers. Docker is an open platform for app development, shipping, and running. Docker allows us to decouple our apps from our infrastructure, allowing us to release software swiftly.  Docker allows us to bundle and run an application in a container, which is a loosely isolated environment. Because of the isolation and security, we can run multiple containers on a single host at the same time. Containers are lightweight and include everything required to run a program, eliminating the need to rely on what is currently installed on the host. }}{3}{section*.12}%
\contentsline {paragraph}{\normalfont {Docker provides a container life-cycle management platform and related tooling and thus:}}{3}{section*.13}%
\contentsline {paragraph}{\normalfont {In the case of online multiplayer game, docker enables easy management of game servers and allows for deployment on the cloud. This allows an instance of the game to run on the nearest cloud server to the user solving the issues of latency. As there are multiple docker containers running the server, the performance is boosted. Further, using docker containers enables support for rolling deployment, auto-scaling, monitoring and maintenance of the game server.}}{3}{section*.14}%
\contentsline {section}{\numberline {1.2}Related Works}{3}{section.1.2}%
\contentsline {subsection}{\numberline {1.2.1}Pokémon GO}{3}{subsection.1.2.1}%
\contentsline {paragraph}{\normalfont {Pokémon Go is an augmented reality (AR) mobile game released in 2016 as part of the Pokémon series by Niantic in conjunction with Nintendo and The Pokémon Company for iOS and Android devices. It use GPS-enabled mobile devices to identify, capture, train, and battle virtual monsters known as Pokémon, who appear to be in the player's real-world location. The game began with approximately 150 Pokémon species, which had grown to approximately 700 by 2021. Pokémon Go uses many services across google cloud, cloud data-store acting as game's primary database for storing the game world.}}{4}{figure.1.1}%
\contentsline {paragraph}{\normalfont {The graph in Fig. \ref {fig:poke} portrays the transactions per second estimated and witnessed by the Niantic team. They targeted 1X player traffic, with a worst-case estimate of nearly 5X that target. Pokémon GO’s popularity quickly surged player traffic to 50X the initial target, ten times the worst-case estimate. In response the Google CRE (Customer Reliability Engineering) team had to provision extra capacity on behalf of Niantic to keep up with this surge.}}{4}{section*.16}%
\contentsline {paragraph}{\normalfont {Pokémon GO, in addition to being a global craze, is one of the most fascinating examples of container-based development in the wild. The game's application logic runs on Google Kubernetes Engine (GKE), which is powered by the open source Kubernetes project. Niantic picked GKE so that their team could concentrate on releasing live modifications to its players. Niantic leveraged Google Cloud in this way to transform Pokémon GO into a service for millions of players, constantly changing and improving.}}{5}{section*.17}%
\contentsline {subsection}{\numberline {1.2.2}Super Mario}{5}{subsection.1.2.2}%
\contentsline {paragraph}{\normalfont {Super Mario is a 2D and 3D platform game series created by Nintendo based on and starring the fictional plumber Mario. At least one Super Mario game has been released for every major Nintendo video game console. There are over twenty games in the series}}{5}{section*.18}%
\contentsline {paragraph}{\normalfont {\emph {PengBAI}, a docker hub user, has made a fan game of Super Mario called Infinite Mario using HTML5 JavaScript. They have made use of docker to distribute this fan game and allow others to play the game. This work is similar to our project but it only makes use of docker as a distribution mechanism and does not aim to perform any optimisations for having better latencies. This game only has a support for a single player and completely runs on the client side. }}{5}{section*.19}%
\contentsline {subsection}{\numberline {1.2.3}Minecraft}{5}{subsection.1.2.3}%
\contentsline {paragraph}{\normalfont {Minecraft is a 3D sandbox game originally created by Markus "Notch" Persson. It is maintained by Mojang Studios, a part of Xbox Game Studios, which in turn is part of Microsoft. One of the simplest examples that people have used over the years of demoing Docker is quickly standing up and running a Minecraft server. This shows the power of using Docker and has a pretty practical application.}}{5}{section*.20}%
\contentsline {paragraph}{\normalfont {There are various images in docker hub for Minecraft servers with various configurations, however, each instance of the server runs on only one container making scalability an issue. }}{5}{section*.21}%
\contentsline {subsection}{\numberline {1.2.4}Among Us}{5}{subsection.1.2.4}%
\contentsline {paragraph}{\normalfont {Among Us is a 2018 online multiplayer social deduction game developed and published by American game studio Innersloth. The game was inspired by the party game Mafia and the science fiction horror film The Thing. The game allows for cross-platform play, first being released on iOS and Android devices. }}{5}{section*.22}%
\contentsline {paragraph}{\normalfont {Among Us is a classic example of an online multiplayer game. It provides support for public and private rooms, i.e., players can play the game together with a group of friends in the private instance of the game or connect to public instances to play with strangers. The game server is hosted in North America, Asia and Europe to provide more connectivity, however, the game is not containerized and thus can not run on nearest cloud server available to the player. }}{6}{section*.23}%
\contentsline {section}{\numberline {1.3}Problem Statement and objectives}{6}{section.1.3}%
\contentsline {section}{\numberline {1.4}Organization of the Report}{6}{section.1.4}%
\contentsline {paragraph}{\normalfont {Chapter 1 provides an overview of the project. It covers relevant works that are similar to ours and served as inspirations for creating this project. This chapter also contains the problem statement and the work objectives.}}{6}{section*.24}%
\contentsline {paragraph}{\normalfont {Chapter 2 contains a literature review, in which we detail all of the technical articles that we have read in order to better grasp the concepts behind this project and come up with relevant changes and features to add.}}{7}{section*.25}%
\contentsline {paragraph}{\normalfont {Chapter 3 interprets the system's high-level design. This section also includes the project's architecture, functional requirements, non-functional requirements, and software development process used.}}{7}{section*.26}%
\contentsline {paragraph}{\normalfont {Chapter 4 focuses on the project's implementation phase. It discusses the tools and technologies used in the project, as well as the project's implementation procedure.}}{7}{section*.27}%
\contentsline {paragraph}{\normalfont {The details of the test scenarios we evaluated for testing our application are presented in Chapter 5. It also includes a results section where the work's output is documented.}}{7}{section*.28}%
\contentsline {paragraph}{\normalfont {The conclusion to the project is presented in Chapter 6. It also includes potential future work connected to this project.}}{7}{section*.29}%
\contentsline {chapter}{\numberline {2}Literature Survey}{8}{chapter.2}%
\contentsline {paragraph}{\normalfont {Many works and papers were referred and the following things were noted.}}{8}{section*.30}%
\contentsline {paragraph}{\normalfont {Cloud gaming is the gaming industry's future, allowing consumers to play games from any location, at any time, and on any device. The research \cite {paper1} covers the two key difficulties in cloud gaming: resource allocation and maintaining user experience quality. \cite {paper1} also discusses how to improve cloud gaming performance by initialising the cloud gaming package inside Docker containers, which will allow the application to be more reliable by secularising its resource allocation and increasing the overall performance of the cloud gaming system while utilising fewer resources.}}{8}{section*.31}%
\contentsline {paragraph}{\normalfont {The real-time strategy game StartCraft: Brood War is a popular area for AI study, with a pre-installed library of AI programming tools supporting all major StarCraft bot kinds. \cite {paper2} shows a Dockered version of StarCraft.Despite StarCraft's restricted OS support, the implementation in \cite {paper2} provides an easy way to deploy StarCraft AIs on several hosts at once and across multiple platforms. \cite {paper2} also covers the Docker image design and shows a few use scenarios.}}{8}{section*.32}%
\contentsline {paragraph}{\normalfont {Mobile Edge Computing (MEC) is a new network paradigm that provides cloud and IT services at the network's point of access. Such proximity to the end user results in ultra-low latency and high bandwidth, while also reducing the congestion in the network core. Because servers must be run on edge nodes, a major component of MEC systems is server mobility and low overhead. \cite {paper3} suggests using Docker as a tool for this purpose. Docker is a technology that enables the quick and easy deployment of Linux containers. \cite {paper3} investigates Docker's usefulness in MEC settings by quantifying the CPU utilised by Docker when operating two different containerized services: multiplayer gaming and video streaming. The authors' tests with varying numbers of clients and servers in \cite {paper3} yield different results for the two case studies: for the gaming service, the overhead logged by Docker increases only with the number of servers; for the video streaming case, the overhead is unaffected by the number of either clients or servers.}}{9}{section*.33}%
\contentsline {paragraph}{\normalfont {Recent advancements in cloud computing enable cloud gaming to give users with a high-end quality of experience. \cite {paper4} asserts that the fundamental requirement of gaming is to deliver the best possible gamer experience; nevertheless, cloud gaming falls short in this regard because the network transmission of game scenes from cloud game server to gamer device is long. Through this study, the author hopes to reduce latency and improve performance in cloud gaming. Based on the Node selection algorithm, \cite {paper4} recommends shifting the cloud game server to the fog nodes located at the player's edge network. \cite {paper4} also advises that traditional virtual machines be replaced by lightweight containers to improve cloud gaming performance.}}{9}{section*.34}%
\contentsline {paragraph}{\normalfont {HTML5 has given many developers the opportunity to explore with new web development options. The authors' goal with \cite {paper5} is to provide a high-level summary of what this entails for the game development community. \cite {paper5} assesses new HTML5 and JavaScript elements. It also emphasises WebGL, Canvas, and WebSockets, which have enabled developers to expand their creativity by modifying images, generating 3D worlds, and allowing real-time interactivity.}}{9}{section*.35}%
\contentsline {paragraph}{\normalfont {Big Two is a multiplayer online game featuring erroneous facts. Each player in this game plays without knowing the opponent's confidential information. \cite {paper6} uses Big Two as an example to demonstrate the requirement for web-based multiplayer games with imperfect information to have real-time communication in order to handle rapid information changes and the game state at any time. \cite {paper6} suggests a new architecture for web-based multiplayer games with incomplete information. \cite {paper6} uses an open-source WebSocket, Socket.IO, as a case study and implements this framework in Big Two.}}{9}{section*.36}%
\contentsline {chapter}{\numberline {3}High-level Design}{10}{chapter.3}%
\contentsline {section}{\numberline {3.1}Software development Methodology}{10}{section.3.1}%
\contentsline {subsection}{\numberline {3.1.1}Agile Methodology}{10}{subsection.3.1.1}%
\contentsline {paragraph}{\normalfont {The Agile methodology is a project management technique that focuses on building a project iteratively by dividing it into small deliverable stages. At each stage, it requires continuous collaboration and progress. When the job begins, agile teams go through the cycle of planning, execution, and evaluation. }}{11}{section*.37}%
\contentsline {paragraph}{\normalfont {Fig. \ref {fig:a1} shows the agile methodology. The product backlog is prepared after requirement analysis and is consists of all the features that are to be implemented in the project. A sprint is a brief period of time during which a team works to complete a specific amount of work. A sprint backlog is then prepared from the product backlog which consists of the tasks to be completed in a particular sprint. This process is referred to as sprint planning. }}{11}{section*.38}%
\contentsline {paragraph}{\normalfont {The following activities happen within a sprint cycle as shown in Fig. \ref {fig:a2}: }}{11}{section*.39}%
\contentsline {paragraph}{\normalfont {The sprint cycles are repeated for each increment of the project. }}{12}{section*.40}%
\contentsline {subsection}{\numberline {3.1.2}Why Agile for our project?}{12}{subsection.3.1.2}%
\contentsline {paragraph}{\normalfont {We have made use of the Agile methodology for the development of this project as it offers the following advantages over traditional methods: }}{12}{section*.41}%
\contentsline {section}{\numberline {3.2}Architecture}{13}{section.3.2}%
\contentsline {paragraph}{\normalfont {The architecture of a system describes its structure and behaviour. It also comprises a graphical depiction of the ideas, concepts, elements, and components of the system.}}{13}{section*.42}%
\contentsline {paragraph}{\normalfont {The following are the major components of the architecture of our project as shown in Fig. \ref {fig:archi}: }}{13}{section*.43}%
\contentsline {section}{\numberline {3.3}Functional Requirements}{15}{section.3.3}%
\contentsline {paragraph}{\normalfont {A functional requirement in software engineering and systems engineering describes a function of a system or its component, where a function is defined as a specification of behaviour between inputs and outputs.}}{15}{section*.44}%
\contentsline {paragraph}{\normalfont {Calculations, technical details, data manipulation and processing, and other specific functionality that define what a system is expected to perform are some functional requirements. Behavioural requirements explain all of the situations in which the system applies functional requirements, which are documented in use cases.}}{15}{section*.45}%
\contentsline {subsection}{\numberline {3.3.1}Scenes}{15}{subsection.3.3.1}%
\contentsline {subsubsection}{\numberline {3.3.1.1}BootScene}{15}{subsubsection.3.3.1.1}%
\contentsline {paragraph}{\normalfont {This class loads all the required assets for the game. It shows a loading image until loading of all the assets is complete.}}{15}{section*.46}%
\contentsline {subsubsection}{\numberline {3.3.1.2}GameScene}{15}{subsubsection.3.3.1.2}%
\contentsline {paragraph}{\normalfont {This class renders the current game state to the user. It renders the neccessary images, adds the colliders and initializes other players. It obtains all the required data from the server using listeners and displays it to the users. It uses the listeners from the \emph {Listeners} class}}{15}{section*.47}%
\contentsline {subsection}{\numberline {3.3.2}Listeners}{15}{subsection.3.3.2}%
\contentsline {paragraph}{\normalfont {This class implements various listeners for the different events that occur in the game. Any module in the application can make use of the listeners implemented in this file. It makes use of sockets to receive events broadcasted by other users and to broadcast events. The following are the important listeners implemented.}}{15}{section*.48}%
\contentsline {subsection}{\numberline {3.3.3}Client}{17}{subsection.3.3.3}%
\contentsline {subsubsection}{\numberline {3.3.3.1}Player}{17}{subsubsection.3.3.3.1}%
\contentsline {paragraph}{\normalfont {This class implements the logic required for handling a player in the game. It keeps track of the main player (representing the current user), obtains the inputs from the user and makes the camera follow the main player with smooth animation.}}{17}{section*.49}%
\contentsline {subsubsection}{\numberline {3.3.3.2}Enemy}{17}{subsubsection.3.3.3.2}%
\contentsline {paragraph}{\normalfont {This class implements the logic required for handling an enemy in the game. It represents one enemy unit and track the players to follow and attack them. }}{17}{section*.50}%
\contentsline {subsection}{\numberline {3.3.4}Server}{17}{subsection.3.3.4}%
\contentsline {subsubsection}{\numberline {3.3.4.1}Proxy}{17}{subsubsection.3.3.4.1}%
\contentsline {paragraph}{\normalfont {We make of Nginx for the proxy. We have implemented it in a way that \emph {subdomain.domain} request is mapped to the \emph {subdomain} docker container.}}{17}{section*.51}%
\contentsline {subsubsection}{\numberline {3.3.4.2}Main Server}{17}{subsubsection.3.3.4.2}%
\contentsline {paragraph}{\normalfont {The main server is the primary server, which facilitates all the functionalities of the game including OAuth and creation of public and private rooms. It notifies the database and docker manager instance that a new game is to be started. }}{17}{section*.52}%
\contentsline {subsubsection}{\numberline {3.3.4.3}Game Server}{17}{subsubsection.3.3.4.3}%
\contentsline {paragraph}{\normalfont {This class listens for the socket events and broadcasts the data. It creates the procedural maps using room\textunderscore generator. The room\textunderscore generator generates a procedural map for a level. It first initializes a 11*11 matrix, and sets the middle of this matrix as the start room. It uses the Drunkard Walk algorithm to populate the rest of the matrix until the maximum number of rooms for all the types of rooms are created. Based on that matrix, we create the map with variable width and height. We then generate the walls for each room and the pathway between the rooms as given by the algorithm. We then add the location of the colliders and overlappers. The map is converted into JSON format and returned to the client.}}{18}{section*.53}%
\contentsline {subsubsection}{\numberline {3.3.4.4}Docker Manager}{18}{subsubsection.3.3.4.4}%
\contentsline {paragraph}{\normalfont {The docker manager class handles the creation and deletion of rooms. During the creation of a room, the docker manager allocates the necessary resources to a container and notifies the database. }}{18}{section*.54}%
\contentsline {subsubsection}{\numberline {3.3.4.5}Database}{18}{subsubsection.3.3.4.5}%
\contentsline {paragraph}{\normalfont {We use the database primarily to store the state of the game. We store the state for each room (A room represents a group of users playing together) which a group of users connect to. We store the room ID, the members of the room, their characters and respective inventory ie., the weapons, coins collected etc.}}{18}{section*.55}%
\contentsline {section}{\numberline {3.4}Non-Functional Requirements}{18}{section.3.4}%
\contentsline {paragraph}{\normalfont {A non-functional requirement (NFR) is a requirement in systems engineering and requirements engineering that specifies criteria that can be used to judge the performance of a system rather than specific behaviours. They differ from functional requirements, which define precise behaviour or functions. The system design includes a thorough plan for implementing functional requirements. Because non-functional requirements are frequently architecturally significant, the plan for implementing them is outlined in the system architecture.}}{18}{section*.56}%
\contentsline {chapter}{\numberline {4}Implementation}{20}{chapter.4}%
\contentsline {section}{\numberline {4.1}Tools and Technologies}{20}{section.4.1}%
\contentsline {paragraph}{\normalfont {The following are software tools and technologies that we have employed in this project: }}{20}{section*.57}%
\contentsline {subsection}{\numberline {4.1.1}Server Side}{20}{subsection.4.1.1}%
\contentsline {subsection}{\numberline {4.1.2}Client Side}{20}{subsection.4.1.2}%
\contentsline {subsection}{\numberline {4.1.3}Development}{21}{subsection.4.1.3}%
\contentsline {subsection}{\numberline {4.1.4}Deployment}{21}{subsection.4.1.4}%
\contentsline {subsection}{\numberline {4.1.5}Testing the latency and response times}{21}{subsection.4.1.5}%
\contentsline {section}{\numberline {4.2}Implementation}{22}{section.4.2}%
\contentsline {subsection}{\numberline {4.2.1}UML Diagrams}{22}{subsection.4.2.1}%
\contentsline {subsubsection}{\numberline {4.2.1.1}Use-Case Diagram}{22}{subsubsection.4.2.1.1}%
\contentsline {paragraph}{\normalfont {The Fig. \ref {fig:uc1} shows the use case of a user creating a room. The user requests the server to create a room. The server generates a unique identifier for the game sessions and notifies the docker manager to start the game session. The server stores the unique identifier and the docker manager stores the container information in the database. The created container acts as a server for the created game instance i.e., room. This room information is sent to the user upon successful creation. }}{23}{figure.4.2}%
\contentsline {paragraph}{\normalfont {The Fig. \ref {fig:uc2} shows the use case of a user joining a room. The user is authenticated and the identity is established. To connect to a private room, the user must provide the unique room identifier. Whereas, to connect to connect to a puiblic room, the user is connected to the closest room from a list open rooms. Once a user joins a room, the data is broadcasted to all the existing players in the room. }}{23}{figure.4.3}%
\contentsline {paragraph}{\normalfont {The Fig. \ref {fig:uc3} shows the use case of an action being performed by a player. The user actions are mapped to the events in the server and these events are broadcasted to other players to notify them about the changes brought about in the game by that action. This is a constant two-way communication between players and server to facilitate a seamless gameplay experience. }}{23}{section*.60}%
\contentsline {subsubsection}{\numberline {4.2.1.2}Sequence Diagram}{24}{subsubsection.4.2.1.2}%
\contentsline {paragraph}{\normalfont {The sequence diagram for the project is as shown in Fig. \ref {fig:seq}. A sequence diagram chronologically shows the different events that occur throughout the life cycle of the game. }}{24}{section*.61}%
\contentsline {paragraph}{\normalfont {The sequence diagrm shows the following events: }}{24}{section*.62}%
\contentsline {chapter}{\numberline {5}Testing}{25}{chapter.5}%
\contentsline {paragraph}{\normalfont {This section provides an overview of testing, testing procedure, and test case information. Software testing is a mechanism for ensuring the proper functionality of software as well as determining whether or not the application fits the defined requirements. They verify that the application is bug and defect free. This ensures that the final consumer receives a high-quality product.}}{25}{section*.63}%
\contentsline {section}{\numberline {5.1}Test Workflow}{25}{section.5.1}%
\contentsline {paragraph}{\normalfont {Testing is done to uncover problems in the product at an early stage, before the product is put into production. Testing can be performed at various levels, such as module and sub-module. The entire product can be tested to guarantee proper module integration and that the product is fault-free from start to finish. There are numerous testing procedures available. These methodologies necessitate distinct strategies and test the numerous components that comprise the application.}}{25}{section*.64}%
\contentsline {paragraph}{\normalfont {A variety of tests are run on the developed application before it is deployed. Tests are carried out to ensure that the application is carrying out the required duties correctly. A test suite is a collection of tests with a common goal. Fig. \ref {fig:test} shows the classification of testing methodologies. The methodologies that are relevant to our work are briefly described in the following sections. }}{26}{figure.5.1}%
\contentsline {subsection}{\numberline {5.1.1}Objectives of Testing}{26}{subsection.5.1.1}%
\contentsline {paragraph}{\normalfont {The process of discovering defects in a program is known as testing. The purpose of the testing is to find errors that aren't immediately apparent to the developer or user but cause problems with the application's workflow. It is a way of detecting flaws or vulnerabilities in a code base in a methodical manner. The main advantage of testing is that it assures that the product fits the end-user criteria before it is issued for use. It also verifies that it is logically correct. Testing ensures that the application workflow is followed and that it functions as intended. The testing is done from the perspective of the users, thus all possible edge situations will be examined, lowering the danger of the application breaking.}}{27}{section*.66}%
\contentsline {subsection}{\numberline {5.1.2}Test Cases}{27}{subsection.5.1.2}%
\contentsline {paragraph}{\normalfont {The fundamental unit of the testing paradigm is the test case. They can be used to test a single entity, the functionality of a complete module, or the integration of the modules. To produce a more dependable product, additional test cases must be written to evaluate the application's end-to-end functionality while taking boundary conditions into account. A large number of test cases aids in determining the accuracy and efficacy of a project.}}{27}{section*.67}%
\contentsline {subsection}{\numberline {5.1.3}Black-Box Testing}{27}{subsection.5.1.3}%
\contentsline {paragraph}{\normalfont {Black box testing is another name for behavioural testing. This type of testing is largely concerned with the functionality of the application. In general, the individual performing black-box testing does not need to understand how the program works internally. This form of testing can handle the following types of errors.}}{27}{section*.68}%
\contentsline {subsection}{\numberline {5.1.4}White-Box Testing}{27}{subsection.5.1.4}%
\contentsline {paragraph}{\normalfont {White-box testing is a type of software testing that examines an application's internal structures or workings rather than its functionality. To design test cases in white-box testing, an internal perspective of the system as well as programming abilities are used. The tester selects inputs to exercise code routes and identify expected outputs. White-box testing can be used in the software testing process at the unit, integration, and system levels. Data flow within a unit, Data flow between units during integration, and Data flow between subsystems during a system-level test can all be tested. This testing methodology applies in the following situations: }}{27}{section*.69}%
\contentsline {subsection}{\numberline {5.1.5}Unit Testing}{28}{subsection.5.1.5}%
\contentsline {paragraph}{\normalfont {Unit testing is in charge of testing the application's most basic unit. A unit is a little piece of code that can be thought of as its own program. It is used to ensure the authenticity of a module by checking for faults. The basic operation of the modules and their sub-modules is validated. Module interactions are also checked to ensure that data is passed between modules as expected. Unit testing is carried out throughout the product development process. Following the completion of product development, the units are tested to ensure that they continue to function as intended.}}{28}{section*.70}%
\contentsline {subsection}{\numberline {5.1.6}Integration Testing}{28}{subsection.5.1.6}%
\contentsline {paragraph}{\normalfont {Integration testing is the stage of  testing in which related sub-modules joined and assessed as a group. Integration testing is used to determine whether a system or component meets the functional requirements. It happens after unit testing but before system testing. Integration testing takes as input unit-tested modules, collects them into bigger aggregates, applies tests described in an integration test plan to those aggregates, and outputs the integrated system suitable for system testing. Top-down or bottom-up integration testing might be used.}}{28}{section*.71}%
\contentsline {subsection}{\numberline {5.1.7}Functional Testing}{28}{subsection.5.1.7}%
\contentsline {paragraph}{\normalfont {Functional testing is a sort of black-box testing, where the test cases on a software component being tested is base on the specifications of the component. This testing method concentrates on the system's functional components while neglecting the logical features of the application.}}{28}{section*.72}%
\contentsline {section}{\numberline {5.2}Test Case Details}{29}{section.5.2}%
\contentsline {subsection}{\numberline {5.2.1}Test Case ID: 1}{29}{subsection.5.2.1}%
\contentsline {subsection}{\numberline {5.2.2}Test Case ID: 2}{29}{subsection.5.2.2}%
\contentsline {subsection}{\numberline {5.2.3}Test Case ID: 3}{29}{subsection.5.2.3}%
\contentsline {subsection}{\numberline {5.2.4}Test Case ID: 4}{29}{subsection.5.2.4}%
\contentsline {subsection}{\numberline {5.2.5}Test Case ID: 5}{30}{subsection.5.2.5}%
\contentsline {section}{\numberline {5.3}Results}{30}{section.5.3}%
\contentsline {paragraph}{\normalfont {Fig. \ref {fig:op1} shows the response time of client instances of the game as seen in BurpSuite. It can be seen that the response time is very low and is in the range of 240 - 250 milliseconds (ms). }}{30}{figure.5.3}%
\contentsline {paragraph}{\normalfont {Fig. \ref {fig:op3} shows the response time of the request from the server to the client as seen in BurpSuite. It can be seen that we have achieved a low response time of 243 (ms). }}{30}{section*.74}%
\contentsline {paragraph}{\normalfont {Fig. shows the latency of the application as 236 (871 - 635) as seen from the Google Chrome inspect}}{30}{section*.75}%
\contentsline {paragraph}{\normalfont {Fig. is a still from the game showing the movement of the player chracter in the room and some bullets being fired from it. }}{30}{section*.76}%
\contentsline {paragraph}{\normalfont {Fig. shows the teleportation of the player characters. The still also shows the closure of the room boundary when all the player characters enter. }}{31}{section*.77}%
\contentsline {paragraph}{\normalfont {Fig. shows some enemy characters swarming towards the player character. }}{31}{section*.78}%
\contentsline {chapter}{\numberline {6}Conclusions and Future Scope}{32}{chapter.6}%
\contentsline {paragraph}{\normalfont {The online multiplayer games constitute a significant portion on the gaming industry. With an active userbase of more than two billion players, the industry is worth around thirty thousand crores. Consequently, it is very important for the games to be highly scalable for meeting the evergrowing demands. To enhance user experience, it is crucial for the games to have low latency and feel more responsive.}}{32}{section*.79}%
\contentsline {paragraph}{\normalfont {We have used docker containers for the game server. The containers allow us to easily manage, monitor and maintain the game server. They allow clound deployment, reduce latency by running an instance of the game on the cloud server nearest to the user, boost server performance by using multiple docker containers to run the server, it also enables support for rolling deployment and auto-scaling.}}{32}{section*.80}%
\contentsline {paragraph}{\normalfont {We have built an online multiplayer game that allow users from across the globe to connect and play together. The game would be a 2D multiplayer game that supports features like orthogonal Top-down view, co-op combat, Character customization and public and private rooms for game sessions.}}{32}{section*.81}%
\contentsline {section}{\numberline {6.1}Future Scope}{32}{section.6.1}%
\contentsline {paragraph}{\normalfont {The following additional enhancements can be implemented in this project for better game-play experience: }}{32}{section*.82}%
\contentsline {chapter}{Bibliography}{34}{section*.83}%
